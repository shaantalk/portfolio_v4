"use strict";(self.webpackChunksantanu_dev=self.webpackChunksantanu_dev||[]).push([[1353],{7710:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var o=n(5893),a=n(1151);const i={slug:"JavaScript Closure",title:"JavaScript Closure",authors:"shaantalk",tags:["blog","closure"],keywords:["JavaScript Closure"],description:"JavaScript Closure"},s=void 0,r={permalink:"/blog/JavaScript Closure",source:"@site/blog/2023-12-03-JS-Closure/index.md",title:"JavaScript Closure",description:"JavaScript Closure",date:"2023-12-03T00:00:00.000Z",formattedDate:"December 3, 2023",tags:[{label:"blog",permalink:"/blog/tags/blog"},{label:"closure",permalink:"/blog/tags/closure"}],readingTime:6.71,hasTruncateMarker:!1,authors:[{name:"Santanu Panda",title:"Cloud Engineer @ Cisco",url:"https://github.com/shaantalk",imageURL:"img/santanu.jpg",key:"shaantalk"}],frontMatter:{slug:"JavaScript Closure",title:"JavaScript Closure",authors:"shaantalk",tags:["blog","closure"],keywords:["JavaScript Closure"],description:"JavaScript Closure"},unlisted:!1,prevItem:{title:"Unveiling the Secrets of Array.forEach() in JavaScript",permalink:"/blog/JavaScript Array ForEach"}},l={authorsImageUrls:[void 0]},c=[{value:"What is a closure ?",id:"what-is-a-closure-",level:2},{value:"Example",id:"example",level:2},{value:"The Var vs. Let Dilemma",id:"the-var-vs-let-dilemma",level:2},{value:"Unveiling the Magic",id:"unveiling-the-magic",level:2},{value:"Bonus Content",id:"bonus-content",level:2},{value:"Solution 1: Use <code>let</code> instead of <code>var</code>",id:"solution-1-use-let-instead-of-var",level:3},{value:"Solution 2: Pass the value of <code>i</code> as a parameter to <code>setTimeout</code>",id:"solution-2-pass-the-value-of-i-as-a-parameter-to-settimeout",level:3},{value:"Solution 3: Use an IIFE (Immediately Invoked Function Expression)",id:"solution-3-use-an-iife-immediately-invoked-function-expression",level:3},{value:"Solution 4: Use <code>bind</code> to set the context and pass parameters",id:"solution-4-use-bind-to-set-the-context-and-pass-parameters",level:3}];function h(e){const t={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"what-is-a-closure-",children:"What is a closure ?"}),"\n",(0,o.jsx)(t.p,{children:"JavaScript closures are functions that can access values outside of their own curly braces."}),"\n",(0,o.jsx)(t.p,{children:"In order to call a function in your code, the JavaScript interpreter needs to know about the function itself and any other data from the surrounding environment that it depends on. Everything needs to be neatly closed up into a box before it can be fed into the machine."}),"\n",(0,o.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/RdnSg76vlOQ?si=mWXMJo0Cd4fnwjrZ",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,o.jsx)(t.p,{children:"Take for example a pure function that only depends on its own arguments and internal data."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"function add(x, y) {\n  return x + y;\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"What we have here is a fully self-contained closed expression. When it's called it gets pushed onto the call stack where it's executed and its internal data is only kept in memory until it's popped back off the call stack."}),"\n",(0,o.jsx)(t.p,{children:"But what if that function references data outside of its own scope like from the global environment or an outer function ? That leaves us with an open expression that references other free variables throughout the environment."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"function outerFunction() {\n  let outerVariable = 10;\n\n  function innerFunction(x) {\n    return x + outerVariable;\n  }\n  return innerFunction;\n}\n\n// Create a closure by assigning the inner function to a variable\nlet closure = outerFunction();\n\n// Now, the closure can access the outerVariable\n// even though it's no longer directly in the scope\nlet result = closure(5); // This will be 15 (5 + 10)\n"})}),"\n",(0,o.jsx)(t.p,{children:"Now in order for the interpreter to call this function and also know the value of these free variables, it creates a closure to store them in a place in memory where they can be accessed later. That area of memory is called the heap. And unlike the call stack which is short-lived, heap can keep data in memory indefinitely then decide when it needs to get rid of it later with the garbage collector"}),"\n",(0,o.jsx)(t.p,{children:"So a closure is not just a function it's a function combined with its outer state or lexical environment."}),"\n",(0,o.jsx)(t.p,{children:"We can create a closure by defining an outer function that contains the state, then an inner function that operates on it. The data contained here will not leak out to the surrounding environment. The inner function has access to data defined in the outer function scope but the outer function does not have access to the inner function."}),"\n",(0,o.jsx)(t.p,{children:"In addition many javascript apis are callback based and you can use closures to create a function factory that takes an argument then returns a brand new function which can then be passed along to other functions that expect a callback."}),"\n",(0,o.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,o.jsx)(t.p,{children:"Let's take a look at one of the most famous javascript trick questions"}),"\n",(0,o.jsx)(t.p,{children:"what does this code log out."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"\n// Famous JavaScript trick question\nfor (var i = 0; i < 3; i++) {\n  function log() {\n    console.log(i);\n  }\n  setTimeout(log, 100);\n}`\n"})}),"\n",(0,o.jsx)(t.p,{children:"let's go through it line by line first we're declaring a variable i with the var keyword. Then a for loop that will run three times by incrementing that variable. Now inside the for loop is where closures come into play. We define a function log that console logs the global variable i"}),"\n",(0,o.jsx)(t.p,{children:"This is not a pure function because it depends on a variable outside of its scope, therefore creating a closure. Then from there we set up a timeout and pass the log function as the callback."}),"\n",(0,o.jsx)(t.p,{children:"This queues up a task to execute the log function after 100 milliseconds"}),"\n",(0,o.jsx)(t.p,{children:"So what do you think the output of this code will be ?"}),"\n",(0,o.jsx)(t.p,{children:"We're capturing the i variable in the closure for each iteration of the loop so it would seem like it should log out as 0 1 2."}),"\n",(0,o.jsx)(t.p,{children:"But if we log it out it actually console logs 3 three times"}),"\n",(0,o.jsx)(t.h2,{id:"the-var-vs-let-dilemma",children:"The Var vs. Let Dilemma"}),"\n",(0,o.jsx)(t.p,{children:"To understand why that happens we also need to understand the difference between var and let. When you use var in a for loop that variable actually gets hoisted up into the parent scope which in this case would be the global scope."}),"\n",(0,o.jsx)(t.p,{children:"Watch what happens when we change the variable to let we get our original expectation of a console log of 0 1 2."}),"\n",(0,o.jsx)(t.p,{children:"With var we have a global variable that we're mutating over and over again but with let we're creating a variable that is scoped to the for loop."}),"\n",(0,o.jsx)(t.p,{children:"In other words it's local to the for loop and can't be accessed outside of it."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"// Fixing the issue with let\nfor (let i = 0; i < 3; i++) {\n  function log() {\n    console.log(i);\n  }\n  setTimeout(log, 100);\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"Now remember"}),"\n",(0,o.jsx)(t.p,{children:"A closure is the combination of a function and its lexical environment. In the case of let the closure is capturing the log function along with the variable i for each iteration of the loop which would be 0 1 2."}),"\n",(0,o.jsx)(t.p,{children:"if we didn't have a closure here javascript would allocate that i variable in memory in the call stack and then immediately release it but because we do have a closure it stores that variable in the heap memory so it can be referenced again when that closure is called by the timeout in the future."}),"\n",(0,o.jsx)(t.p,{children:"But when var is used it's capturing the reference to the global variable. The reason it logs three three times is because the timeout doesn't run until 100 milliseconds later, which is long after that for loop has completed and iterated up to three."}),"\n",(0,o.jsx)(t.h2,{id:"unveiling-the-magic",children:"Unveiling the Magic"}),"\n",(0,o.jsx)(t.p,{children:"We can actually examine this behaviour in the browser dev tools by adding a debugger to the closure. if you try to run this code in the browser with the devtools open. it will take you to the sources tab and allow you to inspect the call stack and scope of the function. When let is used you can see we have a block scoped variable named i but when var is used that variable is now in the global scope which changes the way it's captured by the closure"}),"\n",(0,o.jsx)(t.h2,{id:"bonus-content",children:"Bonus Content"}),"\n",(0,o.jsx)(t.p,{children:"Now that we are done with closure. Lets also check few different solutions to get 0 1 2 from the previous question."}),"\n",(0,o.jsx)(t.p,{children:"In the first solution which we already discussed we have used let, instead of var to achieve this."}),"\n",(0,o.jsxs)(t.h3,{id:"solution-1-use-let-instead-of-var",children:["Solution 1: Use ",(0,o.jsx)(t.code,{children:"let"})," instead of ",(0,o.jsx)(t.code,{children:"var"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"for (let i = 0; i < 3; i++) {\n  function log() {\n    console.log(i);\n  }\n\n  setTimeout(log, 100);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Using ",(0,o.jsx)(t.code,{children:"let"})," creates a block-scoped variable, so each iteration of the loop gets its own variable ",(0,o.jsx)(t.code,{children:"i"}),", and the closure inside ",(0,o.jsx)(t.code,{children:"setTimeout"})," captures the correct value."]}),"\n",(0,o.jsxs)(t.h3,{id:"solution-2-pass-the-value-of-i-as-a-parameter-to-settimeout",children:["Solution 2: Pass the value of ",(0,o.jsx)(t.code,{children:"i"})," as a parameter to ",(0,o.jsx)(t.code,{children:"setTimeout"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"for (var i = 0; i < 3; i++) {\n  function log(index) {\n    console.log(index);\n  }\n\n  setTimeout(log, 100, i);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["By passing ",(0,o.jsx)(t.code,{children:"i"})," as a parameter to the ",(0,o.jsx)(t.code,{children:"log"})," function inside ",(0,o.jsx)(t.code,{children:"setTimeout"}),", you are creating a separate copy of ",(0,o.jsx)(t.code,{children:"i"})," for each invocation of ",(0,o.jsx)(t.code,{children:"log"}),", preventing the closure issue."]}),"\n",(0,o.jsx)(t.h3,{id:"solution-3-use-an-iife-immediately-invoked-function-expression",children:"Solution 3: Use an IIFE (Immediately Invoked Function Expression)"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"for (var i = 0; i < 3; i++) {\n  (function (index) {\n    setTimeout(function () {\n      console.log(index);\n    }, 100);\n  })(i);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["An IIFE creates a new scope for each iteration of the loop, allowing you to capture the correct value of ",(0,o.jsx)(t.code,{children:"i"})," inside the closure."]}),"\n",(0,o.jsxs)(t.h3,{id:"solution-4-use-bind-to-set-the-context-and-pass-parameters",children:["Solution 4: Use ",(0,o.jsx)(t.code,{children:"bind"})," to set the context and pass parameters"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"for (var i = 0; i < 3; i++) {\n  function log(index) {\n    console.log(index);\n  }\n\n  setTimeout(log.bind(null, i), 100);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"bind"})," method allows you to set the context (",(0,o.jsx)(t.code,{children:"null"})," in this case) and also pass parameters to the function. This way, you can ensure that the correct value of ",(0,o.jsx)(t.code,{children:"i"})," is passed to the ",(0,o.jsx)(t.code,{children:"log"})," function."]}),"\n",(0,o.jsxs)(t.p,{children:["Each of these solutions addresses the closure issue and ensures that the correct value of ",(0,o.jsx)(t.code,{children:"i"})," is logged in the ",(0,o.jsx)(t.code,{children:"setTimeout"})," callback i.e. 0 1 2"]})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var o=n(7294);const a={},i=o.createContext(a);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);